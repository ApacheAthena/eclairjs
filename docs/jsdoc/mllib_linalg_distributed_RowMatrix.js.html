<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: mllib/linalg/distributed/RowMatrix.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: mllib/linalg/distributed/RowMatrix.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*                                                                         
* Copyright 2016 IBM Corp.                                                 
*                                                                          
* Licensed under the Apache License, Version 2.0 (the "License");          
* you may not use this file except in compliance with the License.         
* You may obtain a copy of the License at                                  
*                                                                          
*      http://www.apache.org/licenses/LICENSE-2.0                          
*                                                                          
* Unless required by applicable law or agreed to in writing, software      
* distributed under the License is distributed on an "AS IS" BASIS,        
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
* See the License for the specific language governing permissions and      
* limitations under the License.                                           
*/ 



/**
 * Represents a row-oriented distributed Matrix with no meaningful row indices.
 *
 * @classdesc
 * @param {RDD} rows stored as an RDD[Vector]
 * @param {number} [nRows] number of rows. A non-positive value means unknown, and then the number of rows will
 *              be determined by the number of records in the RDD `rows`.
 * @param {number} [nCols] number of columns. A non-positive value means unknown, and then the number of
 *              columns will be determined by the size of the first row.
 * @class
 * @extends {DistributedMatrix}
 */
var RowMatrix = function(rows,nRows,nCols) {
	this.logger = Logger.getLogger("RowMatrix_js");
	var jvmObject;
	if (arguments[0] instanceof org.apache.spark.mllib.linalg.distributed.RowMatrix) {
		jvmObject = arguments[0];
	} else if (arguments.length === 3) {
		jvmObject = new org.apache.spark.mllib.linalg.distributed.RowMatrix(Utils.unwrapObject(rows).rdd(),nRows,nCols);
	} else {
		jvmObject = new org.apache.spark.mllib.linalg.distributed.RowMatrix(Utils.unwrapObject(rows).rdd());
	}


	 DistributedMatrix.call(this, jvmObject);

};

RowMatrix.prototype = Object.create(DistributedMatrix.prototype);

RowMatrix.prototype.constructor = RowMatrix;


/**
 * Computes the Gramian matrix `A^T A`. Note that this cannot be computed on matrices with
 * more than 65535 columns.
 * @returns {Matrix} 
 */
RowMatrix.prototype.computeGramianMatrix = function() {
   var javaObject =  this.getJavaObject().computeGramianMatrix();
   return Utils.javaToJs(javaObject);
};


/**
 * Computes singular value decomposition of this matrix. Denote this matrix by A (m x n). This
 * will compute matrices U, S, V such that A ~= U * S * V', where S contains the leading k
 * singular values, U and V contain the corresponding singular vectors.
 *
 * At most k largest non-zero singular values and associated vectors are returned. If there are k
 * such values, then the dimensions of the return will be:
 *  - U is a RowMatrix of size m x k that satisfies U' * U = eye(k),
 *  - s is a Vector of size k, holding the singular values in descending order,
 *  - V is a Matrix of size n x k that satisfies V' * V = eye(k).
 *
 * We assume n is smaller than m, though this is not strictly required.
 * The singular values and the right singular vectors are derived
 * from the eigenvalues and the eigenvectors of the Gramian matrix A' * A. U, the matrix
 * storing the right singular vectors, is computed via matrix multiplication as
 * U = A * (V * S^-1^), if requested by user. The actual method to use is determined
 * automatically based on the cost:
 *  - If n is small (n &amp;lt; 100) or k is large compared with n (k &amp;gt; n / 2), we compute
 *    the Gramian matrix first and then compute its top eigenvalues and eigenvectors locally
 *    on the driver. This requires a single pass with O(n^2^) storage on each executor and
 *    on the driver, and O(n^2^ k) time on the driver.
 *  - Otherwise, we compute (A' * A) * v in a distributive way and send it to ARPACK's DSAUPD to
 *    compute (A' * A)'s top eigenvalues and eigenvectors on the driver node. This requires O(k)
 *    passes, O(n) storage on each executor, and O(n k) storage on the driver.
 *
 * Several internal parameters are set to default values. The reciprocal condition number rCond
 * is set to 1e-9. All singular values smaller than rCond * sigma(0) are treated as zeros, where
 * sigma(0) is the largest singular value. The maximum number of Arnoldi update iterations for
 * ARPACK is set to 300 or k * 3, whichever is larger. The numerical tolerance for ARPACK's
 * eigen-decomposition is set to 1e-10.
 *
 * @note The conditions that decide which method to use internally and the default parameters are
 *       subject to change.
 *
 * @param {integer} k  number of leading singular values to keep (0 &amp;lt; k &amp;lt;= n).
 *          It might return less than k if
 *          there are numerically zero singular values or there are not enough Ritz values
 *          converged before the maximum number of Arnoldi update iterations is reached (in case
 *          that matrix A is ill-conditioned).
 * @param {boolean} computeU  whether to compute U
 * @param {float} rCond  the reciprocal condition number. All singular values smaller than rCond * sigma(0)
 *              are treated as zero, where sigma(0) is the largest singular value.
 * @returns {SingularValueDecomposition}  SingularValueDecomposition(U, s, V). U = null if computeU = false.
 */
RowMatrix.prototype.computeSVD = function(k,computeU,rCond) {
   var javaObject =  this.getJavaObject().computeSVD(k,computeU,rCond);
   return new SingularValueDecomposition(javaObject);
};


/**
 * Computes the covariance matrix, treating each row as an observation. Note that this cannot
 * be computed on matrices with more than 65535 columns.
 * @returns {Matrix}  a local dense matrix of size n x n
 */
RowMatrix.prototype.computeCovariance = function() {
   var javaObject =  this.getJavaObject().computeCovariance();
   return Utils.javaToJs(javaObject);
};


/**
 * Computes the top k principal components.
 * Rows correspond to observations and columns correspond to variables.
 * The principal components are stored a local matrix of size n-by-k.
 * Each column corresponds for one principal component,
 * and the columns are in descending order of component variance.
 * The row data do not need to be "centered" first; it is not necessary for
 * the mean of each column to be 0.
 *
 * Note that this cannot be computed on matrices with more than 65535 columns.
 *
 * @param {integer} k  number of top principal components.
 * @returns {Matrix}  a matrix of size n-by-k, whose columns are principal components
 */
RowMatrix.prototype.computePrincipalComponents = function(k) {
   var javaObject =  this.getJavaObject().computePrincipalComponents(k);
   return Utils.javaToJs(javaObject);
};


/**
 * Computes column-wise summary statistics.
 * @returns {MultivariateStatisticalSummary} 
 */
RowMatrix.prototype.computeColumnSummaryStatistics = function() {
throw "not implemented by ElairJS";
//   var javaObject =  this.getJavaObject().computeColumnSummaryStatistics();
//   return Utils.javaToJs(javaObject);
};


/**
 * Multiply this matrix by a local matrix on the right.
 *
 * @param {Matrix} B  a local matrix whose number of rows must match the number of columns of this matrix
 *         which preserves partitioning
 * @returns {RowMatrix}  a [[org.apache.spark.mllib.linalg.distributed.RowMatrix]] representing the product,
 */
RowMatrix.prototype.multiply = function(B) {
   var B_uw = Utils.unwrapObject(B);
   var javaObject =  this.getJavaObject().multiply(B_uw);
   return new RowMatrix(javaObject);
};


/**
 * Compute similarities between columns of this matrix using a sampling approach.
 *
 * The threshold parameter is a trade-off knob between estimate quality and computational cost.
 *
 * Setting a threshold of 0 guarantees deterministic correct results, but comes at exactly
 * the same cost as the brute-force approach. Setting the threshold to positive values
 * incurs strictly less computational cost than the brute-force approach, however the
 * similarities computed will be estimates.
 *
 * The sampling guarantees relative-error correctness for those pairs of columns that have
 * similarity greater than the given similarity threshold.
 *
 * To describe the guarantee, we set some notation:
 * Let A be the smallest in magnitude non-zero element of this matrix.
 * Let B be the largest  in magnitude non-zero element of this matrix.
 * Let L be the maximum number of non-zeros per row.
 *
 * For example, for {0,1} matrices: A=B=1.
 * Another example, for the Netflix matrix: A=1, B=5
 *
 * For those column pairs that are above the threshold,
 * the computed similarity is correct to within 20% relative error with probability
 * at least 1 - (0.981)^10/B^
 *
 * The shuffle size is bounded by the *smaller* of the following two expressions:
 *
 * O(n log(n) L / (threshold * A))
 * O(m L^2^)
 *
 * The latter is the cost of the brute-force approach, so for non-zero thresholds,
 * the cost is always cheaper than the brute-force approach.
 *
 * @param {number} [threshold]  Set to 0 for deterministic guaranteed correctness.
 *                  Similarities above this threshold are estimated
 *                  with the cost vs estimate quality trade-off described above.
 *         between columns of this matrix.
 * @returns {CoordinateMatrix}  An n x n sparse upper-triangular matrix of cosine similarities
 */
RowMatrix.prototype.columnSimilarities = function(threshold) {
throw "not implemented by ElairJS";
// 
//   if (arguments[0]) {
//   var javaObject =  this.getJavaObject().columnSimilarities(threshold);
//   return new CoordinateMatrix(javaObject);
//   } else {
//   var javaObject =  this.getJavaObject().columnSimilarities();
//   return new CoordinateMatrix(javaObject);
//   }
};


/**
 * Compute QR decomposition for {@link RowMatrix}. The implementation is designed to optimize the QR
 * decomposition (factorization) for the {@link RowMatrix} of a tall and skinny shape.
 * Reference:
 *  Paul G. Constantine, David F. Gleich. "Tall and skinny QR factorizations in MapReduce
 *  architectures"  ([[http://dx.doi.org/10.1145/1996092.1996103]])
 *
 * @param {boolean} computeQ  whether to computeQ
 * @returns {QRDecomposition}  QRDecomposition(Q, R), Q = null if computeQ = false.
 */
RowMatrix.prototype.tallSkinnyQR = function(computeQ) {
throw "not implemented by ElairJS";
//   var javaObject =  this.getJavaObject().tallSkinnyQR(computeQ);
//   return new QRDecomposition(javaObject);
};

/**
 * Gets RDD of Vectors
 * @returns {RDD} RDD of Vectors
 */
RowMatrix.prototype.rows = function() {
   var javaObject =  this.getJavaObject().rows();
   return Utils.javaToJs(javaObject);
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Accumulable.html">Accumulable</a></li><li><a href="AccumulableParam.html">AccumulableParam</a></li><li><a href="Accumulator.html">Accumulator</a></li><li><a href="ALS.html">ALS</a></li><li><a href="ArrayType.html">ArrayType</a></li><li><a href="AssociationRules.html">AssociationRules</a></li><li><a href="BinaryClassificationMetrics.html">BinaryClassificationMetrics</a></li><li><a href="BinaryType.html">BinaryType</a></li><li><a href="BisectingKMeans.html">BisectingKMeans</a></li><li><a href="BisectingKMeansModel.html">BisectingKMeansModel</a></li><li><a href="BooleanType.html">BooleanType</a></li><li><a href="BoostingStrategy.html">BoostingStrategy</a></li><li><a href="CalendarIntervalType.html">CalendarIntervalType</a></li><li><a href="Column.html">Column</a></li><li><a href="DataFrame.html">DataFrame</a></li><li><a href="DataFrameHolder.html">DataFrameHolder</a></li><li><a href="DataFrameNaFunctions.html">DataFrameNaFunctions</a></li><li><a href="DataFrameReader.html">DataFrameReader</a></li><li><a href="DataFrameStatFunctions.html">DataFrameStatFunctions</a></li><li><a href="DataFrameWriter.html">DataFrameWriter</a></li><li><a href="DataType.html">DataType</a></li><li><a href="DataTypes.html">DataTypes</a></li><li><a href="DateType.html">DateType</a></li><li><a href="DecisionTree.html">DecisionTree</a></li><li><a href="DecisionTreeModel.html">DecisionTreeModel</a></li><li><a href="DenseMatrix.html">DenseMatrix</a></li><li><a href="DenseVector.html">DenseVector</a></li><li><a href="DistributedLDAModel.html">DistributedLDAModel</a></li><li><a href="DistributedMatrix.html">DistributedMatrix</a></li><li><a href="DoubleType.html">DoubleType</a></li><li><a href="DStream.html">DStream</a></li><li><a href="Duration.html">Duration</a></li><li><a href="FloatAccumulatorParam.html">FloatAccumulatorParam</a></li><li><a href="FloatRDD.html">FloatRDD</a></li><li><a href="FloatType.html">FloatType</a></li><li><a href="FPGrowth.html">FPGrowth</a></li><li><a href="FPGrowthModel.html">FPGrowthModel</a></li><li><a href="FreqItemset.html">FreqItemset</a></li><li><a href="functions.html">functions</a></li><li><a href="FutureAction.html">FutureAction</a></li><li><a href="GeneralizedLinearModel.html">GeneralizedLinearModel</a></li><li><a href="Gradient.html">Gradient</a></li><li><a href="GradientBoostedTrees.html">GradientBoostedTrees</a></li><li><a href="GradientBoostedTreesModel.html">GradientBoostedTreesModel</a></li><li><a href="GroupedData.html">GroupedData</a></li><li><a href="HashPartitioner.html">HashPartitioner</a></li><li><a href="IntAccumulatorParam.html">IntAccumulatorParam</a></li><li><a href="IntegerType.html">IntegerType</a></li><li><a href="IsotonicRegression.html">IsotonicRegression</a></li><li><a href="IsotonicRegressionModel.html">IsotonicRegressionModel</a></li><li><a href="KMeans.html">KMeans</a></li><li><a href="KMeansModel.html">KMeansModel</a></li><li><a href="LabeledPoint.html">LabeledPoint</a></li><li><a href="LBFGS.html">LBFGS</a></li><li><a href="LDA.html">LDA</a></li><li><a href="LDAModel.html">LDAModel</a></li><li><a href="LinearRegressionModel.html">LinearRegressionModel</a></li><li><a href="LinearRegressionWithSGD.html">LinearRegressionWithSGD</a></li><li><a href="List.html">List</a></li><li><a href="LocalLDAModel.html">LocalLDAModel</a></li><li><a href="Logger.html">Logger</a></li><li><a href="LogisticGradient.html">LogisticGradient</a></li><li><a href="LogisticRegressionModel.html">LogisticRegressionModel</a></li><li><a href="LogisticRegressionWithLBFGS.html">LogisticRegressionWithLBFGS</a></li><li><a href="LogisticRegressionWithSGD.html">LogisticRegressionWithSGD</a></li><li><a href="Loss.html">Loss</a></li><li><a href="MapType.html">MapType</a></li><li><a href="Matrix.html">Matrix</a></li><li><a href="MatrixFactorizationModel.html">MatrixFactorizationModel</a></li><li><a href="Metadata.html">Metadata</a></li><li><a href="MLWord2Vec.html">MLWord2Vec</a></li><li><a href="MLWord2VecModel.html">MLWord2VecModel</a></li><li><a href="MulticlassMetrics.html">MulticlassMetrics</a></li><li><a href="MultilabelMetrics.html">MultilabelMetrics</a></li><li><a href="NaiveBayes.html">NaiveBayes</a></li><li><a href="NaiveBayesModel.html">NaiveBayesModel</a></li><li><a href="NullType.html">NullType</a></li><li><a href="NumericType.html">NumericType</a></li><li><a href="PairDStream.html">PairDStream</a></li><li><a href="PairRDD.html">PairRDD</a></li><li><a href="PartialResult.html">PartialResult</a></li><li><a href="Partitioner.html">Partitioner</a></li><li><a href="PowerIterationClustering.html">PowerIterationClustering</a></li><li><a href="PowerIterationClusteringAssignment.html">PowerIterationClusteringAssignment</a></li><li><a href="PowerIterationClusteringModel.html">PowerIterationClusteringModel</a></li><li><a href="PrefixSpan.html">PrefixSpan</a></li><li><a href="PrefixSpanFreqSequence.html">PrefixSpanFreqSequence</a></li><li><a href="PrefixSpanModel.html">PrefixSpanModel</a></li><li><a href="QRDecomposition.html">QRDecomposition</a></li><li><a href="RandomForest.html">RandomForest</a></li><li><a href="RandomForestModel.html">RandomForestModel</a></li><li><a href="RangePartitioner.html">RangePartitioner</a></li><li><a href="RankingMetrics.html">RankingMetrics</a></li><li><a href="Rating.html">Rating</a></li><li><a href="RDD.html">RDD</a></li><li><a href="RegressionMetrics.html">RegressionMetrics</a></li><li><a href="Row.html">Row</a></li><li><a href="RowFactory.html">RowFactory</a></li><li><a href="RowMatrix.html">RowMatrix</a></li><li><a href="Rule.html">Rule</a></li><li><a href="SingularValueDecomposition.html">SingularValueDecomposition</a></li><li><a href="SparkConf.html">SparkConf</a></li><li><a href="SparkContext.html">SparkContext</a></li><li><a href="SparkFiles.html">SparkFiles</a></li><li><a href="SparkStatusTracker.html">SparkStatusTracker</a></li><li><a href="SparseMatrix.html">SparseMatrix</a></li><li><a href="SparseVector.html">SparseVector</a></li><li><a href="SQLContext.html">SQLContext</a></li><li><a href="SQLContext.QueryExecution.html">QueryExecution</a></li><li><a href="SQLContext.SparkPlanner.html">SparkPlanner</a></li><li><a href="SQLContext.SQLSession.html">SQLSession</a></li><li><a href="SqlDate.html">SqlDate</a></li><li><a href="SqlTimestamp.html">SqlTimestamp</a></li><li><a href="SquaredL2Updater.html">SquaredL2Updater</a></li><li><a href="StorageLevel.html">StorageLevel</a></li><li><a href="Strategy.html">Strategy</a></li><li><a href="StreamingContext.html">StreamingContext</a></li><li><a href="StringType.html">StringType</a></li><li><a href="StructField.html">StructField</a></li><li><a href="StructType.html">StructType</a></li><li><a href="SVMModel.html">SVMModel</a></li><li><a href="SVMWithSGD.html">SVMWithSGD</a></li><li><a href="Time.html">Time</a></li><li><a href="TimestampType.html">TimestampType</a></li><li><a href="Tuple.html">Tuple</a></li><li><a href="TwitterAuthorization.html">TwitterAuthorization</a></li><li><a href="Updater.html">Updater</a></li><li><a href="Vector.html">Vector</a></li><li><a href="Vectors.html">Vectors</a></li><li><a href="VectorUDT.html">VectorUDT</a></li><li><a href="Word2Vec.html">Word2Vec</a></li><li><a href="Word2VecModel.html">Word2VecModel</a></li></ul><h3>Interfaces</h3><ul><li><a href="ClassificationModel.html">ClassificationModel</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.2</a> on Wed Mar 23 2016 15:57:04 GMT-0400 (EDT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
